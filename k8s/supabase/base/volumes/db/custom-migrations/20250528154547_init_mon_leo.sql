create table "public"."ChannelUsers" (
    "id" bigint generated by default as identity not null,
    "authorId" uuid not null,
    "channelId" bigint not null,
    "isAdmin" boolean not null default false,
    "hasPinned" boolean not null default false,
    "isSilent" boolean not null default false,
    "isHidden" boolean not null default false,
    "dateLastLecture" timestamp with time zone,
    "dateLastReceived" timestamp with time zone,
    "dateMaxHistory" timestamp with time zone,
    "addedAt" timestamp with time zone not null default now()
);


alter table "public"."ChannelUsers" enable row level security;

create table "public"."Channels" (
    "id" bigint generated by default as identity not null,
    "lastMessageId" bigint,
    "name" text,
    "imageUrl" text,
    "creatorId" uuid,
    "isReadOnly" boolean not null default false,
    "isGroupChat" boolean not null default false,
    "updatedAt" timestamp with time zone not null default now(),
    "createdAt" timestamp with time zone not null default now(),
    "legacyId" bigint,
    "idSite" bigint
);


alter table "public"."Channels" enable row level security;

create table "public"."FcmTokens" (
    "token" text not null,
    "userId" uuid not null,
    "isLoggedIn" boolean not null default false,
    "deviceId" uuid not null
);


alter table "public"."FcmTokens" enable row level security;

create table "public"."Messages" (
    "id" bigint generated by default as identity not null,
    "channelId" bigint not null,
    "authorId" uuid,
    "content" text not null,
    "rawContent" text,
    "replyId" bigint,
    "isImportant" boolean not null default false,
    "isDeleted" boolean not null default false,
    "updatedAt" timestamp with time zone,
    "createdAt" timestamp with time zone not null default now()
);


alter table "public"."Messages" enable row level security;

create table "public"."Migrations" (
    "id" bigint generated by default as identity not null,
    "siteId" bigint not null,
    "startedAt" timestamp with time zone not null default now(),
    "endedAt" timestamp with time zone,
    "status" boolean
);


alter table "public"."Migrations" enable row level security;

create table "public"."Users" (
    "idExterne" uuid not null,
    "idSupabase" uuid,
    "firstname" text not null,
    "lastname" text,
    "avatarUrl" text,
    "createdAt" timestamp with time zone not null default timezone('utc'::text, now()),
    "isService" boolean
);


alter table "public"."Users" enable row level security;

CREATE UNIQUE INDEX "ChannelUsers_pkey" ON public."ChannelUsers" USING btree (id);

CREATE UNIQUE INDEX "Channels_id_key" ON public."Channels" USING btree (id);

CREATE UNIQUE INDEX "Channels_pkey" ON public."Channels" USING btree (id);

CREATE UNIQUE INDEX "FcmTokens_pkey" ON public."FcmTokens" USING btree (token);

CREATE UNIQUE INDEX "Messages_pkey" ON public."Messages" USING btree (id);

CREATE UNIQUE INDEX "Migrations_id_key" ON public."Migrations" USING btree (id);

CREATE UNIQUE INDEX "Migrations_pkey" ON public."Migrations" USING btree (id);

CREATE UNIQUE INDEX "Users_idExterne_key" ON public."Users" USING btree ("idSupabase");

CREATE UNIQUE INDEX unique_channel_user ON public."ChannelUsers" USING btree ("channelId", "authorId");

CREATE UNIQUE INDEX users_pkey ON public."Users" USING btree ("idExterne");

alter table "public"."ChannelUsers" add constraint "ChannelUsers_pkey" PRIMARY KEY using index "ChannelUsers_pkey";

alter table "public"."Channels" add constraint "Channels_pkey" PRIMARY KEY using index "Channels_pkey";

alter table "public"."FcmTokens" add constraint "FcmTokens_pkey" PRIMARY KEY using index "FcmTokens_pkey";

alter table "public"."Messages" add constraint "Messages_pkey" PRIMARY KEY using index "Messages_pkey";

alter table "public"."Migrations" add constraint "Migrations_pkey" PRIMARY KEY using index "Migrations_pkey";

alter table "public"."Users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."ChannelUsers" add constraint "public_ChannelUsers_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "Users"("idExterne") ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."ChannelUsers" validate constraint "public_ChannelUsers_authorId_fkey";

alter table "public"."ChannelUsers" add constraint "public_ChannelUsers_channelId_fkey" FOREIGN KEY ("channelId") REFERENCES "Channels"(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."ChannelUsers" validate constraint "public_ChannelUsers_channelId_fkey";

alter table "public"."ChannelUsers" add constraint "unique_channel_user" UNIQUE using index "unique_channel_user";

alter table "public"."Channels" add constraint "Channels_id_key" UNIQUE using index "Channels_id_key";

alter table "public"."Channels" add constraint "public_Channels_creatorId_fkey" FOREIGN KEY ("creatorId") REFERENCES "Users"("idExterne") ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."Channels" validate constraint "public_Channels_creatorId_fkey";

alter table "public"."FcmTokens" add constraint "public_FcmTokens_userId_fkey" FOREIGN KEY ("userId") REFERENCES "Users"("idExterne") ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."FcmTokens" validate constraint "public_FcmTokens_userId_fkey";

alter table "public"."Messages" add constraint "public_Messages_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "Users"("idExterne") ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."Messages" validate constraint "public_Messages_authorId_fkey";

alter table "public"."Messages" add constraint "public_Messages_channelId_fkey" FOREIGN KEY ("channelId") REFERENCES "Channels"(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."Messages" validate constraint "public_Messages_channelId_fkey";

alter table "public"."Migrations" add constraint "Migrations_id_key" UNIQUE using index "Migrations_id_key";

alter table "public"."Users" add constraint "Users_idExterne_key" UNIQUE using index "Users_idExterne_key";

alter table "public"."Users" add constraint "public_Users_idExterne_fkey" FOREIGN KEY ("idSupabase") REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."Users" validate constraint "public_Users_idExterne_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.auth_id()
 RETURNS uuid
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  (SELECT "idExterne" FROM public."Users" WHERE "idSupabase" = auth.uid());  
$function$
;

CREATE OR REPLACE FUNCTION public.channel_already_exist(creatorid uuid, userid uuid)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$ 
BEGIN
  RETURN 
    (SELECT c.id from "Channels" c
    inner join public."ChannelUsers" cu on cu."channelId" = c.id 
    inner join public."ChannelUsers" cu2 on cu2."channelId" = c.id
    WHERE cu."authorId" = userid and cu2."authorId" = creatorid and c."isGroupChat" = false
  );
END
$function$
;

CREATE OR REPLACE FUNCTION public.create_channel(ids uuid[], creatorid uuid, isgroup boolean, name text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$DECLARE
    channelid INTEGER;
	userid UUID;
	existingid INTEGER;
BEGIN	
	-- Check if a one to one already exist
	IF array_length(ids, 1) < 2 THEN
		SELECT channel_already_exist(ids[1], creatorid) INTO existingid;
		IF existingid IS NOT NULL THEN
			RETURN existingid;
		END IF;
	END IF;
	
	-- Create channel
    INSERT INTO public."Channels"("creatorId", "isGroupChat", name)
	VALUES (creatorid, isgroup, name)
	RETURNING id INTO channelid;
	
	-- Add every members
	FOREACH userid IN ARRAY ids LOOP
		INSERT INTO public."ChannelUsers"("authorId", "channelId")
		VALUES (userid, channelid);
	END LOOP;
	
	-- Add creator as admin
	INSERT INTO public."ChannelUsers"("authorId", "channelId", "isAdmin")
	VALUES (creatorid, channelid, true);
	
	RETURN channelid;
END;$function$
;

CREATE OR REPLACE FUNCTION public.existing_channels(users uuid[], creatorid uuid)
 RETURNS TABLE(channelid bigint, userid uuid)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  WITH "channelIdCTE" AS (
    SELECT cu."channelId" as "channelId", cu."authorId" as "userId"
    FROM public."ChannelUsers" cu JOIN public."Channels" c on c.id = cu."channelId"
    WHERE cu."authorId" = ANY(users) 
    AND c."isGroupChat" = false
  )
  SELECT cu2."channelId", "userId"
      FROM public."ChannelUsers" cu2, "channelIdCTE" cte 
      WHERE cu2."channelId" = cte."channelId" AND cu2."authorId" = creatorid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  DECLARE idExterneText TEXT;
  BEGIN
    idExterneText := new.raw_user_meta_data ->> 'idExterne';

    INSERT INTO public."Users" 
      ("idExterne", firstname, lastname, "avatarUrl", "idSupabase")
    VALUES 
      (idExterneText::uuid, 
      new.raw_user_meta_data ->> 'firstname',
      new.raw_user_meta_data ->> 'lastname',
      new.raw_user_meta_data ->> 'avatarUrl',
      new.id)
    ON CONFLICT("idExterne") 
    DO UPDATE SET
    "idSupabase" = new.id;
    
    return new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.inser_msg_user_add()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
  IF ((SELECT c."isGroupChat" from "Channels" as c WHERE c.id = new."channelId" LIMIT 1) AND
  (SELECT c."legacyId" from "Channels" as c WHERE c.id = new."channelId" LIMIT 1) IS NULL)
    THEN
    insert into public."Messages" ("channelId", content)
    values (new."channelId", CONCAT('[USER_ADDED]', (SELECT firstname FROM public."Users" where "idExterne" = new."authorId"), ' ',(SELECT lastname FROM public."Users" where "idExterne" = new."authorId")));
  END IF;  
  return new;
END;$function$
;

CREATE OR REPLACE FUNCTION public.inser_msg_user_delete()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF(EXISTS(SELECT public."Channels".id FROM public."Channels" WHERE public."Channels".id = old."channelId")) THEN
  insert into public."Messages" ("channelId", content)
  values (old."channelId", CONCAT('[USER_REMOVED]', (SELECT firstname FROM public."Users" where public."Users"."idExterne" = old."authorId"), ' ',(SELECT lastname FROM public."Users" where public."Users"."idExterne" = old."authorId")));
  END IF;
  return old;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_msg_channel_img_updt()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
 
  insert into public."Messages" ("channelId", content)
  values (new.id, CONCAT('[CHANNEL_IMG_EDIT]', (SELECT firstname FROM public."Users" where "idExterne" = auth_id()), ' ',(SELECT lastname FROM public."Users" where "idExterne" = auth_id())));
  return new;
  EXCEPTION WHEN OTHERS THEN
  return new;
END;$function$
;

CREATE OR REPLACE FUNCTION public.insert_msg_channel_name_updt()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
 
  insert into public."Messages" ("channelId", content)
  values (new.id, CONCAT('[CHANNEL_RENAMED]', (SELECT firstname FROM public."Users" where "idExterne" = auth_id()), ' ',(SELECT lastname FROM public."Users" where "idExterne" = auth_id())));
  return new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_same_channel(userid uuid, channelid bigint)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
SELECT EXISTS (
  SELECT cu."authorId", cu."channelId"
  FROM public."ChannelUsers" AS cu
  WHERE cu."channelId" = channelid
  AND cu."authorId" = userid
);
$function$
;

CREATE OR REPLACE FUNCTION public.update_channel_on_message_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE public."Channels"
  SET "lastMessageId" = NEW.id
  WHERE id = NEW."channelId";
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_messages()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW."updatedAt" = now();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_on_channels()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW."updatedAt" = now();
    RETURN NEW;
END;
$function$
;

create policy "ChannelUser UPDATE based on userId"
on "public"."ChannelUsers"
as permissive
for update
to public
using ((auth_id() = "authorId"));


create policy "ChannelUsers DELETE based on user Id"
on "public"."ChannelUsers"
as permissive
for delete
to public
using ((is_same_channel(auth_id(), "channelId") AND (( SELECT cu."isAdmin"
   FROM "ChannelUsers" cu
  WHERE ((cu."channelId" = "ChannelUsers"."channelId") AND (cu."authorId" = auth_id()))) OR (auth_id() = "authorId"))));


create policy "ChannelUsers INSERT based on authenticated"
on "public"."ChannelUsers"
as permissive
for insert
to authenticated
with check (true);


create policy "ChannelUsers SELECT based on user Id"
on "public"."ChannelUsers"
as permissive
for select
to public
using (is_same_channel(auth_id(), "channelId"));


create policy "Channel DELETE based on user Id or count"
on "public"."Channels"
as permissive
for delete
to public
using ((is_same_channel(auth_id(), id) OR (( SELECT count("ChannelUsers"."channelId") AS count
   FROM "ChannelUsers"
  WHERE ("ChannelUsers"."channelId" = "ChannelUsers".id)) = 1)));


create policy "Channel INSERT based on authenticated"
on "public"."Channels"
as permissive
for insert
to authenticated
with check (true);


create policy "Channel SELECT based on user Id"
on "public"."Channels"
as permissive
for select
to public
using (((EXISTS ( SELECT cu.id,
    cu."authorId",
    cu."channelId"
   FROM "ChannelUsers" cu
  WHERE (("Channels".id = cu."channelId") AND (cu."authorId" = auth_id())))) OR (auth_id() = "creatorId")));


create policy "Channel UPDATE based on user Id"
on "public"."Channels"
as permissive
for update
to public
using (((EXISTS ( SELECT cu."authorId",
    cu."channelId"
   FROM "ChannelUsers" cu
  WHERE (("Channels".id = cu."channelId") AND (auth_id() = cu."authorId")))) OR ("creatorId" = auth_id())));


create policy "Enable all for authenticated users only"
on "public"."FcmTokens"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Messages INSERT based on user Id"
on "public"."Messages"
as permissive
for insert
to public
with check ((EXISTS ( SELECT c.id,
    c."lastMessageId",
    c.name,
    c."isReadOnly",
    c."createdAt",
    c."updatedAt"
   FROM "Channels" c
  WHERE (("Messages"."channelId" = c.id) AND (EXISTS ( SELECT cu.id,
            cu."authorId",
            cu."channelId",
            cu."dateLastLecture",
            cu."isAdmin",
            cu."hasPinned",
            cu."addedAt"
           FROM "ChannelUsers" cu
          WHERE ((c.id = cu."channelId") AND (cu."authorId" = auth_id()))))))));


create policy "Messages SELECT based on user Id"
on "public"."Messages"
as permissive
for select
to public
using ((EXISTS ( SELECT c.id
   FROM "Channels" c
  WHERE (("Messages"."channelId" = c.id) AND (EXISTS ( SELECT cu.id,
            cu."authorId",
            cu."channelId",
            cu."dateMaxHistory"
           FROM "ChannelUsers" cu
          WHERE ((c.id = cu."channelId") AND (cu."authorId" = auth_id()))))))));


create policy "Messages UPDATE based on user Id"
on "public"."Messages"
as permissive
for update
to public
using ((auth_id() = "authorId"));


create policy "Enable insert for authenticated users only"
on "public"."Users"
as permissive
for insert
to authenticated
with check (true);


create policy "SELECT User if authenticated"
on "public"."Users"
as permissive
for select
to authenticated
using (true);


create policy "UPDATE if authenticated"
on "public"."Users"
as permissive
for update
to authenticated
using (true);


CREATE TRIGGER userdeleted BEFORE DELETE ON public."ChannelUsers" FOR EACH ROW EXECUTE FUNCTION inser_msg_user_delete();

CREATE TRIGGER userinserted AFTER INSERT ON public."ChannelUsers" FOR EACH ROW EXECUTE FUNCTION inser_msg_user_add();

CREATE TRIGGER channelimageupdated AFTER UPDATE OF "imageUrl" ON public."Channels" FOR EACH ROW EXECUTE FUNCTION insert_msg_channel_img_updt();

CREATE TRIGGER channelnameupdated AFTER UPDATE OF name ON public."Channels" FOR EACH ROW EXECUTE FUNCTION insert_msg_channel_name_updt();

CREATE TRIGGER update_channel_updated_on BEFORE UPDATE ON public."Channels" FOR EACH ROW EXECUTE FUNCTION update_updated_on_channels();

CREATE TRIGGER "notif new message" AFTER INSERT ON public."Messages" FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('http://localhost:8000/functions/v1/notif', 'POST', '{"Content-type":"application/json"}', '{}', '1000');

CREATE TRIGGER update_channel_on_message_insert AFTER INSERT ON public."Messages" FOR EACH ROW EXECUTE FUNCTION update_channel_on_message_insert();

CREATE TRIGGER update_message_updated_at BEFORE UPDATE ON public."Messages" FOR EACH ROW EXECUTE FUNCTION update_updated_at_messages();

-- ADD MANUALLY REALTIME ACTIVATION
ALTER PUBLICATION supabase_realtime ADD TABLE "Messages";
ALTER PUBLICATION supabase_realtime ADD TABLE "Channels";
ALTER PUBLICATION supabase_realtime ADD TABLE "ChannelUsers";